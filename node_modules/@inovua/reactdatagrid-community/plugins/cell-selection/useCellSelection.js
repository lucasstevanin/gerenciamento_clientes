/** 
 * Copyright Â© INOVUA TRADING.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useCellSelection = void 0;

var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof"));

var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray"));

var _react = require("react");

var _useProperty3 = _interopRequireDefault(require("@inovua/reactdatagrid-community/hooks/useProperty"));

var _batchUpdate = _interopRequireDefault(require("@inovua/reactdatagrid-community/utils/batchUpdate"));

var _clamp = _interopRequireDefault(require("@inovua/reactdatagrid-community/utils/clamp"));

var _useActiveCell2 = _interopRequireDefault(require("./useActiveCell"));

var getFirstSelectedCell = function getFirstSelectedCell(cellSelection) {
  return cellSelection.sort(function (cell1, cell2) {
    if (cell1[0] < cell2[0]) {
      return -1;
    } else if (cell1[0] > cell2[0]) {
      return 1;
    }

    return cell1[1] < cell2[1] ? -1 : 1;
  })[0];
};

var useCellSelection = function useCellSelection(props, _ref, computedPropsRef) {
  var rowSelectionEnabled = _ref.rowSelectionEnabled,
      hasRowNavigation = _ref.hasRowNavigation,
      listenOnCellEnter = _ref.listenOnCellEnter;

  var _useProperty = (0, _useProperty3.default)(props, 'cellSelection'),
      _useProperty2 = (0, _slicedToArray2.default)(_useProperty, 2),
      cellSelection = _useProperty2[0],
      setCellSelection = _useProperty2[1];

  var _useActiveCell = (0, _useActiveCell2.default)(props, computedPropsRef),
      computedActiveCell = _useActiveCell.computedActiveCell,
      getCellSelectionIdKey = _useActiveCell.getCellSelectionIdKey,
      getCellSelectionBetween = _useActiveCell.getCellSelectionBetween,
      setActiveCell = _useActiveCell.setActiveCell,
      getCellSelectionKey = _useActiveCell.getCellSelectionKey,
      incrementActiveCell = _useActiveCell.incrementActiveCell;

  var cellSelectionEnabled = !rowSelectionEnabled ? !!cellSelection : false;

  if (rowSelectionEnabled || hasRowNavigation) {
    computedActiveCell = undefined;
  }

  var cellNavigationEnabled = computedActiveCell !== undefined;

  if (cellSelection) {
    cellNavigationEnabled = props.enableKeyboardNavigation !== false && !hasRowNavigation ? true : computedActiveCell !== undefined || !!cellSelection;
  }

  if (props.enableKeyboardNavigation === false) {
    cellNavigationEnabled = false;
  }

  var cellMultiSelectionEnabledRef = (0, _react.useRef)(false);
  cellMultiSelectionEnabledRef.current = cellSelectionEnabled && props.multiSelect !== false;
  var cellMultiSelectionEnabled = cellMultiSelectionEnabledRef.current;
  var onCellEnter = (0, _react.useMemo)(function () {
    return listenOnCellEnter ? function (event, _ref2) {
      var columnIndex = _ref2.columnIndex,
          rowIndex = _ref2.rowIndex;
      var computedProps = computedPropsRef.current;

      if (!computedProps) {
        return;
      }

      var data = computedProps.getItemAt(rowIndex);

      if (!data || data.__group) {
        return;
      }

      var col = computedProps.getColumnBy(columnIndex);

      if (col && col.cellSelectable === false) {
        return;
      }

      var groupBy = computedProps.computedGroupBy;
      var minCol = groupBy ? groupBy.length : 0;

      if (columnIndex < minCol) {
        return;
      }

      var range = computedProps.getCellSelectionBetween(computedProps.selectionFixedCell || computedProps.computedActiveCell || computedProps.lastSelectedCell, [rowIndex, columnIndex]);
      var queue = (0, _batchUpdate.default)();
      queue(function () {
        computedProps.setCellSelection(range);
        computedProps.setLastCellInRange(Object.keys(range).pop() || '');
      });
      var direction = computedProps.cellDragStartRowIndex != null ? rowIndex - computedProps.cellDragStartRowIndex : rowIndex;
      var sign = direction < 0 ? -1 : direction > 0 ? 1 : 0;
      var scrollToRowIndex = (0, _clamp.default)(rowIndex + sign, 0, computedProps.count - 1);
      var visible = computedProps.isCellVisible({
        columnIndex: columnIndex,
        rowIndex: scrollToRowIndex
      });

      if (visible !== true) {
        visible = visible;
        var left = visible.leftDiff < 0;
        var top = visible.topDiff < 0;
        computedProps.scrollToCell({
          columnIndex: columnIndex,
          rowIndex: scrollToRowIndex
        }, {
          top: top,
          left: left
        });
      }

      queue.commit();
    } : null;
  }, [listenOnCellEnter]);

  var getContinuousSelectedRangeFor = function getContinuousSelectedRangeFor(selectionMap, cell) {
    if (!cell) {
      return [];
    }

    selectionMap = selectionMap || {};

    var _cell = (0, _slicedToArray2.default)(cell, 2),
        row = _cell[0],
        col = _cell[1];

    var key = getCellSelectionKey(row, col);
    var range = [];

    while (selectionMap[key]) {
      range.push([row, col]);
      key = getCellSelectionKey(row - 1, col - 1);

      if (selectionMap[key]) {
        row -= 1;
        col -= 1;
        continue;
      }

      if (!selectionMap[key]) {
        key = getCellSelectionKey(row - 1, col);
      }

      if (selectionMap[key]) {
        row -= 1;
        continue;
      }

      if (!selectionMap[key]) {
        key = getCellSelectionKey(row, col - 1);
        col -= 1;
      }
    }

    return range;
  };

  var toggleActiveCellSelection = (0, _react.useCallback)(function (fakeEvent) {
    var computedProps = computedPropsRef.current;

    if (!computedProps) {
      return;
    }

    var computedActiveCell = computedProps.computedActiveCell;

    if (!computedActiveCell) {
      return;
    }

    var _computedActiveCell = (0, _slicedToArray2.default)(computedActiveCell, 2),
        rowIndex = _computedActiveCell[0],
        columnIndex = _computedActiveCell[1];

    var column = computedProps.getColumnBy(columnIndex);

    if (column && column.cellSelectable === false) {
      return;
    }

    var selected = isCellSelected(rowIndex, columnIndex);
    var event = fakeEvent || {
      ctrlKey: selected
    };
    computedProps.onCellClickAction(event, {
      rowIndex: rowIndex,
      columnIndex: columnIndex
    });
  }, []);
  var isCellSelected = (0, _react.useCallback)(function (row, col) {
    if (row && (0, _typeof2.default)(row) === 'object') {
      col = row.columnIndex;
      row = row.rowIndex;
    }

    var computedProps = computedPropsRef.current;

    if (!computedProps) {
      return;
    }

    if (computedProps.computedCellSelection) {
      var key = computedProps.getCellSelectionKey(row, col);
      return !!computedProps.computedCellSelection[key];
    }

    return false;
  }, []);

  var _useState = (0, _react.useState)(null),
      _useState2 = (0, _slicedToArray2.default)(_useState, 2),
      cellDragStartRowIndex = _useState2[0],
      setCellDragStartRowIndex = _useState2[1];

  var cellSelectionRef = (0, _react.useRef)(cellSelection);
  cellSelectionRef.current = cellSelection;
  var onCellSelectionDraggerMouseDown = (0, _react.useMemo)(function () {
    if (cellMultiSelectionEnabled && cellSelectionRef.current) {
      var _onCellSelectionDraggerMouseDown = function _onCellSelectionDraggerMouseDown(event, _ref3, selectionFixedCell) {
        var columnIndex = _ref3.columnIndex,
            rowIndex = _ref3.rowIndex;
        var computedProps = computedPropsRef.current;

        if (!computedProps) {
          return;
        }

        var column = computedProps.getColumnBy(columnIndex);

        if (column && column.cellSelectable === false) {
          return;
        }

        if (!selectionFixedCell) {
          var currentCell = [rowIndex, columnIndex];
          var groupBy = computedProps.computedGroupBy;
          var hasGroupBy = groupBy && groupBy.length;
          var currentRange = !hasGroupBy ? getContinuousSelectedRangeFor(computedProps.computedCellSelection, currentCell) : [];
          selectionFixedCell = !hasGroupBy ? getFirstSelectedCell(currentRange.length ? currentRange : [currentCell]) : computedProps.computedActiveCell || computedProps.lastSelectedCell;
        }

        var fn = function fn() {
          computedProps.setListenOnCellEnter(false, fn);
          setCellDragStartRowIndex(null);
          computedProps.setSelectionFixedCell(null);
        };

        var queue = (0, _batchUpdate.default)();
        queue(function () {
          setCellDragStartRowIndex(rowIndex);

          if (selectionFixedCell === undefined) {
            selectionFixedCell = null;
          }

          computedProps.setSelectionFixedCell(selectionFixedCell);
          computedProps.setListenOnCellEnter(true, fn);
        });
        queue.commit();
      };

      return _onCellSelectionDraggerMouseDown;
    }

    return null;
  }, []);
  return {
    onCellEnter: onCellEnter,
    toggleActiveCellSelection: toggleActiveCellSelection,
    cellDragStartRowIndex: cellDragStartRowIndex,
    setCellDragStartRowIndex: setCellDragStartRowIndex,
    onCellSelectionDraggerMouseDown: onCellSelectionDraggerMouseDown,
    getCellSelectionBetween: getCellSelectionBetween,
    computedActiveCell: computedActiveCell,
    incrementActiveCell: incrementActiveCell,
    getCellSelectionIdKey: getCellSelectionIdKey,
    setActiveCell: setActiveCell,
    getCellSelectionKey: getCellSelectionKey,
    cellSelectionEnabled: cellSelectionEnabled,
    cellNavigationEnabled: cellNavigationEnabled,
    cellMultiSelectionEnabled: cellMultiSelectionEnabled,
    computedCellSelection: cellSelection,
    setCellSelection: setCellSelection
  };
};

exports.useCellSelection = useCellSelection;